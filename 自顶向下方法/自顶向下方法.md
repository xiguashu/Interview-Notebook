# 自顶向下方法

《计算机网络 --自顶向下方法》阅读过程中的整理



## 应用层

#### 1. 套接字（Socket）：进程与计算机网络之间的接口

从一个进程向另一个进程发送的报文必须通过下层的网络，进程通过一个称为套接字的软件接口向网络发送报文和从网络接收报文。进程只负责把报文塞给套接字，且假设该套接字与目的套接字之间有运输的基础设施，该设施会将报文传到目的进程的套接字中。

- 应用程序的要求：可靠数据传输、吞吐量、定时（时延）、安全性
- 安全套接字层（Secure Sockets Layer）是对TCP的加强，这种强化是在应用层上实现的。加密、数据完整性和端点鉴别。



#### 2. HTTP协议

HTTP定义了Web客户向Web服务器请求WEB页面的方式，以及服务器向客户传送WEB页面的方式。

##### 1. 特点

- 基于TCP。建立TCP连接之后往套接字中塞HTTP报文即可。
- 无状态协议。不保存关于客户的任何信息。



##### 2. 非持续连接和持续连接

- 每一个请求建立一个单独的TCP连接 or 同一个主机只建立一个连接
- 非持续连接造成了会给服务器带来很重的负担
- 在持续连接情况下，服务器在发送响应后仍保持连接打开，再次接收到该客户端请求后仍通过该连接发送响应。若在一段时间内某一连接一直未被使用，服务器就关闭该连接。

**在三次握手的最后一次时，主机会将请求和确认消息一并发送**



##### 3. HTTP报文格式

- 请求报文


![httpget](https://github.com/xiguashu/fojiao/blob/master/自顶向下方法/httpget.png)



第一行叫做请求行，包括方法、url和Http版本

后继的行叫做首部行，包括很多乱七八糟的，比如主机域名、上文提到的连接类型、用户代理，即向服务器发送请求的浏览器类型、用户想得到的文件内容、编码方式、语言、和两个不知道是什么的属性。

使用get方法时报文的实体体（entity body）是空的，使用post方法时会在首部后面跟一个实体，比如表单的输入值。书中特别提到表单不一定通过post方法提交，也可通过get，把参数和值挂在url的后面。

- http响应报文

![response](https://github.com/xiguashu/fojiao/blob/master/自顶向下方法/httpresponse.png)

第一行状态行：协议版本、状态码、短语

首部行：服务器名字、连接类型、内容类型、内容长度



#### 3. cookie：用户与服务器的交互

cookie可以帮助服务器识别用户

![cookie](https://github.com/xiguashu/fojiao/blob/master/自顶向下方法/cookie.png)

在用户首次访问某服务器时，服务器给用户生成一个cookie，并保存在数据库中，同时将生成的cookie发给用户，由浏览器记录，下一次用户再访问该服务器时会在http报文头部附上cookie



#### 4. Web缓存

代理服务器，浏览器向代理服务器发送请求，代理服务器再向初始服务器发请求，若代理服务器确认缓存有最新的被请求文件则直接发给浏览器；若没有，则由初始服务器发给代理服务器，代理服务器再发送响应给浏览器，同时在代理服务器上备份文件。它存在的意义是这样做会快很多。



#### 其他基于TCP的应用层协议

FTP（文件传输）

STMP（邮件）



#### 5. DNS : 因特网的目录服务（基于UDP）

DNS是

1. 一个由DNS服务器实现的分布式数据库
2. 一个使得主机能够查询分布式数据库的应用层协议

DNS通常被其他应用层协议所使用、将用户提供的主机名解析为IP地址

工作过程:

1. 浏览器从URL中抽取出主机名，并将主机名传给DNS应用的客户端
2. 客户端向服务器发送一个包含主机名的请求
3. 客户端收到回应报文，得到该主机名对应的IP地址
4. 浏览器得到IP地址，建立TCP连接

获得映射的过程

1. 主机将包含域名的请求发送给本地DNS服务器
2. 本地服务器将该报文转发到根DNS服务器，得到负责管理该域名（比如 .edu）的TLD DNS服务器的列表
3. 本地DNS服务器选择其中之一发送查询报文，得到权威DNS 服务器的IP
4. 本地DNS服务器向权威服务器发送查询、得到最终的IP

![](https://github.com/xiguashu/fojiao/blob/master/自顶向下方法/dns.png)

DNS服务器具有缓存机制



#### 6. Socket 编程

若要使用TCP通信，服务端需要建立两个Socket，一个用于握手，一个用于收发消息



## 运输层

为进程之间提供逻辑通信，只工作于端系统，不关心报文在网络中如何移动

运输层分组叫报文段（segment），网络层分组叫数据报

将主机间交付扩展到进程间交付被称为运输层的多路复用与多路分解



#### 1. 多路复用与多路分解

多路分解：将运输层报文段中的数据交付到正确的套接字

多路复用：将套接字输出的数据收集，为其封装上首部信息，生成报文段，传递到网络层

通过给报文段加上源端口号和目的端口号达成，源端口号是为了回消息



#### 2. UDP协议

UDP只完成了复用/分解的功能（为数据加上源端口，目的端口），以及少量的差错检测（校验和字段，可以检验数据是否出错，错了可以丢弃，但不重发）。

UDP相对于TCP的优势在于：数据传递延迟小、无需连接建立、无连接状态、分组首部开销小

总结起来就是数据传输时效性更强、消耗的资源少。



#### 3. 可靠数据传输原理

- rdt2.0 自动重传请求协议（ARQ），需要三个功能：

差错检测、接收方反馈（ACK）、重传

- 滑动窗口协议（GBN协议）

在《自顶向下》中，对于此协议的说明与《计网期末复习》中所整理的内容有所不同。

对于发送方，需要维护这样几个值：已被确认的序号，下一个即将发送的序号，窗口长度。而对于接收方，需要维护的值只是下一个报文的序号，**没有缓存**。

![](https://github.com/xiguashu/fojiao/blob/master/自顶向下方法/发送方窗口.png)

若接收方收到的报文不是它想要的，则把它扔了，发送ack=想要的序号

发送方的某个分组超时后，会重发这个分组及之后的所有能发的分组

接收方采取这样的策略可以减少缓存资源的浪费；

- 选择重传

![](https://github.com/xiguashu/fojiao/blob/master/自顶向下方法/选择重传.png)

对于接收方：他会缓存失序但未被确认的报文，并且每收到一个报文（无论顺序是否正确）都会返回ack=报文seq+长度；

对于发送方，他会一直发窗口内可发的报文，收到ack后可以将窗口后移；某报文超时就将其重发；

![](https://github.com/xiguashu/fojiao/blob/master/自顶向下方法/选择重传例子.png)

窗口不能太大（分组总数的一半？），否则接收方有可能会分不清是一个新分组还是重传（出现在下一轮开始，且该分组之前的分组丢失时）。



#### 4. TCP : 面向连接的传输

全双工：AB间若有一条TCP连接，则数据可从A流向B，也可从B流向A

点对点

数据通过套接字后，TCP将这些数据引导到该连接的发送缓存中，发送缓存是在三次握手阶段设置的缓存之一。接下来TCP会不时从缓存中取出一块数据以报文段的形式发送数据。数据量受限于最大报文段长度（MMS），MMS又由最大链路层帧长度（最大传输单元MTU）决定。MMS=MTU - IP报头部（20字节）- TCP头部（20字节），典型值为1460字节。

当TCP发送一个大文件时，会将该文件划分成长度为MSS的若干块。

- ##### TCP报文结构

![](https://github.com/xiguashu/fojiao/blob/master/自顶向下方法/TCP结构.png)

序号和确认号：可靠传输/序号是当前分组的第一个字节的序号，确认号是希望接收到的下一个分组（第一个字节）的序号

接受窗口：流量控制，接收方愿意接受的字节数

首部长度：由于选项字段的原因，TCP首部长度是可变的

选项字段：协商最大报文长度

ACK：字段有效

RST/SYN/FIN：连接的建立和拆除

PSH：接收方应立即将数据交到上层

URG：很紧急

- ##### 对于序号（seq）和确认号（ack）的一些说明

在主机A - 主机B的通信过程中，假设是A to B的单方面数据传输

a. A给B发送若干个数据报，并在每个数据报头部加上seq与字节数,同时启动定时器；

b. B每收到一个数据报，返回ack=当前已收到连续序列的最大序号+1，一般情况下是seq+字节长度；同时向上层交付已收到的连续序列的未交付的报文。

c. A收到B的ack报之后知道该确认字节前的所有数据报都已被收到，关闭他们的定时器；

d. 若A的某个定时器超时，则重发该报；

e. 若B收到重复的序列则把该报丢掉，返回ack=当前已收到序列的最大序号+1；

综上，对B来说，他每收到一个数据报，都会返回ack等于已收到的序列的最大序号+1（**积累确认**），且**缓存**。对A主要就是确认B已收到或超时重发。

**TCP的可靠传输机制与回退N步策略的差别在于tcp将失序序列缓存**

**与重传策略差别在于tcp有积累确认机制（每次返回确认正确的序列的最大序号+1）。**



- ##### 超时重发机制过期时间的设置 --拥塞控制的方法之一

每次超时后将过期时间加倍，当收到上次数据或ACK后重新根据RTT计算超时时间；



- ##### 快速重传（SR）

冗余ACK的产生：接收方接收到的序列中间存在间隔，当发送方给接收方发送间隔之后的包时，接收方不断返回ack=间隔前的最大序号。

当发送方接收到三个ack之后，就执行快速重传：传那个ack对应的序号的报文。



- ##### TCP连接的建立与拆除

三次握手和四次挥手



- ##### 拥塞控制原理

  ​

- TCP拥塞控制


慢启动（指数增长）、拥塞避免、快速恢复（线性增长）

1. cwnd从1开始慢启动
2. 若达到阈值，快速恢复；
3. 若期间发生超时，cwnd设为1，重新慢启动，阈值设为cwnd/2；
4. 若期间接收到三个ACK，cwnd减半，则执行快速重传后进入快速恢复状态；


